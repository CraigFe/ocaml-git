<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>IEnc (git.Git__Pack_engine.S.IEnc)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../../index.html">git</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Git__Pack_engine.S.IEnc</span></h1></header><div class="spec module" id="module-Hash"><a href="#module-Hash" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Hash/index.html">Hash</a> : <a href="../../../Git__/S/index.html#module-type-HASH">Git__.S.HASH</a></code></div><div class="doc"><p>The <code class="code">Hash</code> module used to make the implementation.</p></div></div><div class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>error</code><code></code><code></code></div><div class="doc"><p>The type error. We can't have an error to serialize an IDX file - it's
just to homogenize interfaces each others.</p></div></div><div class="spec val" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_error : <a href="index.html#type-error">error</a> Fmt.t</code></div><div class="doc"><p>Pretty-printer of <a href="index.html#type-error">error</a>.</p></div></div><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code></code><code></code></div><div class="doc"><p>The encoder state.</p></div></div><div class="spec val" id="val-pp"><a href="#val-pp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp : <a href="index.html#type-t">t</a> Fmt.t</code></div><div class="doc"><p>Pretty-printer of the encoder <a href="index.html#type-t">t</a>.</p></div></div><div class="spec type" id="type-sequence"><a href="#type-sequence" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a sequence</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit</code><code></code></div><div class="doc"><p>An abstract representation of an iterative container.</p></div></div><div class="spec val" id="val-default"><a href="#val-default" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>default : (<a href="index.html#module-Hash">Hash</a>.t<span class="keyword"> * </span>(Checkseum.Crc32.t<span class="keyword"> * </span>int64)) <a href="index.html#type-sequence">sequence</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#module-Hash">Hash</a>.t <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">default seq pack_hash</code> makes a new encoder to serialize <code class="code">seq</code> and
associates the IDX stream produced with the <code class="code">pack_hash</code> PACK file. This
function takes care about the order of <code class="code">seq</code>, so the client does not need
to sort the iterative container.</p></div></div><div class="spec val" id="val-flush"><a href="#val-flush" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>flush : int <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">flush off len t</code> provides <code class="code">t</code> with <code class="code">len</code> bytes to write, starting at
<code class="code">off</code>. This byte range is written by calls to <a href="index.html#val-eval">eval</a> with <code class="code">t</code> until
<code class="code">`Flush</code> is returned. Use <a href="index.html#val-used_out">used_out</a> to know how many byte <code class="code">t</code> wrote.</p></div></div><div class="spec val" id="val-used_out"><a href="#val-used_out" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>used_out : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">used_out t</code> returns how many byte <code class="code">t</code> wrote in the current buffer
noticed to the previous call of <a href="index.html#val-eval">eval</a>.</p></div></div><div class="spec val" id="val-eval"><a href="#val-eval" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>eval : Cstruct.t <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> [ `Flush of <a href="index.html#type-t">t</a> | `End of <a href="index.html#type-t">t</a> | `Error of <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-error">error</a> ]</code></div><div class="doc"><p><code class="code">eval dst t</code> is:</p><ul><li><code class="code">`Flush t</code> iff <code class="code">t</code> needs more output storage. The client must use
<a href="index.html#val-flush">flush</a> to provide a new buffer and then call <a href="index.html#val-eval">eval</a> with <code class="code">`Flush</code>
until <code class="code">`End</code> is returned.</li><li><code class="code">`End t</code> when the encoder is done. <code class="code">t</code>
sticks to this situation. The client can remove it.</li><li><code class="code">`Error (t, exn)</code>
iff the encoder meet an <a href="index.html#type-error">error</a><code class="code">exn</code>. The encoder can't continue and
sticks in this situation.</li></ul></div></div></body></html>